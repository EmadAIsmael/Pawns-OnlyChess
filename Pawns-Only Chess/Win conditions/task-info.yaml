type: edu
files:
- name: src/chess/Main.kt
  visible: true
  text: |-
    package chess

    fun main() {
    //    write your code here
    }
  learner_created: false
- name: test/PawnsOnlyChessTest.kt
  visible: false
  text: |+
    import org.hyperskill.hstest.dynamic.DynamicTest
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testing.TestedProgram

    class PawnsOnlyChessTest : StageTest<Any>() {
        @DynamicTest
        fun testAdd5(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) { index -> Pair(1, index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) { index -> Pair(6, index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            for (ch in 'a'..'h') {
                outputString = main.execute("${ch}2${ch}4").trim()
                pawnsWhite.remove(Pair(1, ch - 'h' + 7))
                pawnsWhite.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch}7${ch}5").trim()
                pawnsBlack.remove(Pair(6, ch - 'h' + 7))
                pawnsBlack.add(Pair(4, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")
            }

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test1(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2e4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(3, 4))
            outputString = main.execute("d7d5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 3))
            pawnsBlack.add(Pair(4, 3))
            outputString = main.execute("e4d5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 3))
            pawnsWhite.remove(Pair(3, 4))
            pawnsWhite.add(Pair(4, 3))
            outputString = main.execute("c7c6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 2))
            pawnsBlack.add(Pair(5, 2))
            outputString = main.execute("d5d6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(4, 3))
            pawnsWhite.add(Pair(5, 3))
            outputString = main.execute("c6c5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 2))
            pawnsBlack.add(Pair(4, 2))
            outputString = main.execute("d6d7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(5, 3))
            pawnsWhite.add(Pair(6, 3))
            outputString = main.execute("c5c4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 2))
            pawnsBlack.add(Pair(3, 2))
            outputString = main.execute("d7d8").trim()
            pawnsWhite.remove(Pair(6, 3))
            pawnsWhite.add(Pair(7, 3))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after white pawn reaches 8th rank.")
            position = checkOutput(outputString.toLowerCase(), position, "white wins!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after white pawn reaches 8th rank.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test2(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2e4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(3, 4))
            outputString = main.execute("d7d5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 3))
            pawnsBlack.add(Pair(4, 3))
            outputString = main.execute("b2b3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 1))
            pawnsWhite.add(Pair(2, 1))
            outputString = main.execute("d5e4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 4))
            pawnsBlack.remove(Pair(4, 3))
            pawnsBlack.add(Pair(3, 4))
            outputString = main.execute("b3b4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(2, 1))
            pawnsWhite.add(Pair(3, 1))
            outputString = main.execute("e4e3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(3, 4))
            pawnsBlack.add(Pair(2, 4))
            outputString = main.execute("b4b5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 1))
            pawnsWhite.add(Pair(4, 1))
            outputString = main.execute("e3e2").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(2, 4))
            pawnsBlack.add(Pair(1, 4))
            outputString = main.execute("b5b6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(4, 1))
            pawnsWhite.add(Pair(5, 1))
            outputString = main.execute("e2e1").trim()
            pawnsBlack.remove(Pair(1, 4))
            pawnsBlack.add(Pair(0, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after black pawn reaches 1st rank.")
            position = checkOutput(outputString.toLowerCase(), position, "black wins!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after black pawn reaches 1st rank.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test3(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("a2a4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 0))
            pawnsWhite.add(Pair(3, 0))
            outputString = main.execute("b7b5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 1))
            pawnsBlack.add(Pair(4, 1))
            outputString = main.execute("a4b5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 1))
            pawnsWhite.remove(Pair(3, 0))
            pawnsWhite.add(Pair(4, 1))
            outputString = main.execute("c7c6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 2))
            pawnsBlack.add(Pair(5, 2))
            outputString = main.execute("b5c6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 2))
            pawnsWhite.remove(Pair(4, 1))
            pawnsWhite.add(Pair(5, 2))
            outputString = main.execute("a7a5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 0))
            pawnsBlack.add(Pair(4, 0))
            outputString = main.execute("c6d7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 3))
            pawnsWhite.remove(Pair(5, 2))
            pawnsWhite.add(Pair(6, 3))
            outputString = main.execute("a5a4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 0))
            pawnsBlack.add(Pair(3, 0))
            outputString = main.execute("d2d4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 3))
            pawnsWhite.add(Pair(3, 3))
            outputString = main.execute("e7e5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 4))
            pawnsBlack.add(Pair(4, 4))
            outputString = main.execute("d4e5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 4))
            pawnsWhite.remove(Pair(3, 3))
            pawnsWhite.add(Pair(4, 4))
            outputString = main.execute("f7f6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 5))
            pawnsBlack.add(Pair(5, 5))
            outputString = main.execute("e5f6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 5))
            pawnsWhite.remove(Pair(4, 4))
            pawnsWhite.add(Pair(5, 5))
            outputString = main.execute("h7h5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 7))
            pawnsBlack.add(Pair(4, 7))
            outputString = main.execute("f6g7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 6))
            pawnsWhite.remove(Pair(5, 5))
            pawnsWhite.add(Pair(6, 6))
            outputString = main.execute("a4a3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(3, 0))
            pawnsBlack.add(Pair(2, 0))
            outputString = main.execute("b2a3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(2, 0))
            pawnsWhite.remove(Pair(1, 1))
            pawnsWhite.add(Pair(2, 0))
            outputString = main.execute("h5h4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 7))
            pawnsBlack.add(Pair(3, 7))
            outputString = main.execute("c2c3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 2))
            pawnsWhite.add(Pair(2, 2))
            outputString = main.execute("h4h3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(3, 7))
            pawnsBlack.add(Pair(2, 7))
            outputString = main.execute("g2h3").trim()
            pawnsBlack.remove(Pair(2, 7))
            pawnsWhite.remove(Pair(1, 6))
            pawnsWhite.add(Pair(2, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after white captures all black pawns.")
            position = checkOutput(outputString.toLowerCase(), position, "white wins!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after white wins after capturing all black pawns.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test4(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("a2a4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 0))
            pawnsWhite.add(Pair(3, 0))
            outputString = main.execute("b7b5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 1))
            pawnsBlack.add(Pair(4, 1))
            outputString = main.execute("h2h3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 7))
            pawnsWhite.add(Pair(2, 7))
            outputString = main.execute("b5a4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 0))
            pawnsBlack.remove(Pair(4, 1))
            pawnsBlack.add(Pair(3, 0))
            outputString = main.execute("b2b3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 1))
            pawnsWhite.add(Pair(2, 1))
            outputString = main.execute("a4b3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(2, 1))
            pawnsBlack.remove(Pair(3, 0))
            pawnsBlack.add(Pair(2, 1))
            outputString = main.execute("h3h4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(2, 7))
            pawnsWhite.add(Pair(3, 7))
            outputString = main.execute("b3c2").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 2))
            pawnsBlack.remove(Pair(2, 1))
            pawnsBlack.add(Pair(1, 2))
            outputString = main.execute("h4h5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 7))
            pawnsWhite.add(Pair(4, 7))
            outputString = main.execute("c7c5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 2))
            pawnsBlack.add(Pair(4, 2))
            outputString = main.execute("d2d4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 3))
            pawnsWhite.add(Pair(3, 3))
            outputString = main.execute("c5d4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 3))
            pawnsBlack.remove(Pair(4, 2))
            pawnsBlack.add(Pair(3, 3))
            outputString = main.execute("e2e3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(2, 4))
            outputString = main.execute("d4e3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(2, 4))
            pawnsBlack.remove(Pair(3, 3))
            pawnsBlack.add(Pair(2, 4))
            outputString = main.execute("g2g4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 6))
            pawnsWhite.add(Pair(3, 6))
            outputString = main.execute("e3f2").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 5))
            pawnsBlack.remove(Pair(2, 4))
            pawnsBlack.add(Pair(1, 5))
            outputString = main.execute("h5h6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(4, 7))
            pawnsWhite.add(Pair(5, 7))
            outputString = main.execute("g7h6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(5, 7))
            pawnsBlack.remove(Pair(6, 6))
            pawnsBlack.add(Pair(5, 7))
            outputString = main.execute("g4g5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 6))
            pawnsWhite.add(Pair(4, 6))
            outputString = main.execute("h6g5").trim()
            pawnsWhite.remove(Pair(4, 6))
            pawnsBlack.remove(Pair(5, 7))
            pawnsBlack.add(Pair(4, 6))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after black captures all white pawns.")
            position = checkOutput(outputString.toLowerCase(), position, "black wins!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after black wins after capturing all white pawns.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test5(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("a2a4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 0))
            pawnsWhite.add(Pair(3, 0))
            outputString = main.execute("b7b5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 1))
            pawnsBlack.add(Pair(4, 1))
            outputString = main.execute("a4b5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 1))
            pawnsWhite.remove(Pair(3, 0))
            pawnsWhite.add(Pair(4, 1))
            outputString = main.execute("c7c6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 2))
            pawnsBlack.add(Pair(5, 2))
            outputString = main.execute("b5c6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 2))
            pawnsWhite.remove(Pair(4, 1))
            pawnsWhite.add(Pair(5, 2))
            outputString = main.execute("a7a5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 0))
            pawnsBlack.add(Pair(4, 0))
            outputString = main.execute("c6d7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 3))
            pawnsWhite.remove(Pair(5, 2))
            pawnsWhite.add(Pair(6, 3))
            outputString = main.execute("a5a4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 0))
            pawnsBlack.add(Pair(3, 0))
            outputString = main.execute("d2d4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 3))
            pawnsWhite.add(Pair(3, 3))
            outputString = main.execute("e7e5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 4))
            pawnsBlack.add(Pair(4, 4))
            outputString = main.execute("d4e5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 4))
            pawnsWhite.remove(Pair(3, 3))
            pawnsWhite.add(Pair(4, 4))
            outputString = main.execute("f7f6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 5))
            pawnsBlack.add(Pair(5, 5))
            outputString = main.execute("e5f6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 5))
            pawnsWhite.remove(Pair(4, 4))
            pawnsWhite.add(Pair(5, 5))
            outputString = main.execute("h7h5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 7))
            pawnsBlack.add(Pair(4, 7))
            outputString = main.execute("f6g7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 6))
            pawnsWhite.remove(Pair(5, 5))
            pawnsWhite.add(Pair(6, 6))
            outputString = main.execute("a4a3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(3, 0))
            pawnsBlack.add(Pair(2, 0))
            outputString = main.execute("b2a3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(2, 0))
            pawnsWhite.remove(Pair(1, 1))
            pawnsWhite.add(Pair(2, 0))
            outputString = main.execute("h5h4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 7))
            pawnsBlack.add(Pair(3, 7))
            outputString = main.execute("h2h3").trim()
            pawnsWhite.remove(Pair(1, 7))
            pawnsWhite.add(Pair(2, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after white captures all black pawns.")
            position = checkOutput(outputString.toLowerCase(), position, "stalemate!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after white wins after stalemate.")

            return CheckResult.correct()
        }

    }

    fun checkChessboard(outputString: String, searchPos: Int, pawnsWhite: List<Pair<Int, Int>>, pawnsBlack: List<Pair<Int, Int>>): Int {
        fun createChessboardStringList(pawnsWhite: List<Pair<Int, Int>>, pawnsBlack: List<Pair<Int, Int>>): List<String> {
            var chessboard = "  +---+---+---+---+---+---+---+---+\n"
            for (i in 7 downTo 0) {
                chessboard += "${i + 1} |"
                for (j in 0..7) {
                    val square = when {
                        pawnsWhite.contains(Pair(i, j)) -> 'W'
                        pawnsBlack.contains(Pair(i, j)) -> 'B'
                        else -> ' '
                    }
                    chessboard += " $square |"
                }
                chessboard += "\n  +---+---+---+---+---+---+---+---+\n"
            }
            chessboard += "    a   b   c   d   e   f   g   h\n"
    //        println(chessboard)
            return chessboard.trim().split("\n").map { it.trim() }
        }
        val chessboardStringList = createChessboardStringList(pawnsWhite, pawnsBlack)
        return checkOutput(outputString, searchPos, * chessboardStringList.toTypedArray())
    }

    fun checkOutput(outputString: String, searchPos: Int, vararg checkStr: String): Int {
        var searchPosition = searchPos
        for (str in checkStr) {
            val findPosition = outputString.indexOf(str, searchPosition)
            if (findPosition == -1) return -1
            if ( outputString.substring(searchPosition until findPosition).isNotBlank() ) return -1
            searchPosition = findPosition + str.length
        }
        return searchPosition
    }


  learner_created: false
- name: src/chess/Board.kt
  visible: true
  text: |
    package chess

    class Board {
        private val rankCount = 8           // rows in chess are called "ranks".
        private val fileCount = 8           // columns in chess are called "files".
        // private val ranks = ('1'..'8')
        private val files = ('a'..'h')
        private val board = Array(8) {
            Array<Pawn?>(8) {
                null
            }
        }

        fun setSquare(rank: Int, file: Char, piece: Pawn? = null) {
            board[rank - 1][file - 'a'] = piece
        }

        fun resetSquare(rank: Int, file: Char) {
            board[rank - 1][file - 'a'] = null
        }

        fun getSquare(rank: Int, file: Char): Pawn? = board[rank - 1][file - 'a']

        fun getSquare(sqr: Square): Pawn? = board[sqr.rank - 1][sqr.file - 'a']

        fun isFree(to: Square): Boolean {
            return getSquare(to.rank, to.file) == null
        }

        fun display() {
            println(this.toString())
        }

        override fun toString(): String {
            val files = "   " + files.joinToString("") { c ->
                " $c  "
            }
            var str = ""
            val topBottomBoarder = "  +${"---+".repeat(this.fileCount)}\n"

            str += topBottomBoarder
            str += board.reversed().mapIndexed { r, rankRow ->
                "${rankCount - r} |" +
                        rankRow.mapIndexed { _, p ->
                            " ${if (p != null) if (!p.isTaken) p.toString() else " " else " "} |"
                        }.joinToString("") +
                        "\n" + topBottomBoarder
            }.joinToString("")

            str += files
            return str
        }

        fun structurePieces(players: Array<Player>) {
            players.forEach { player ->
                player.pieces.forEach { pawn ->
                    setSquare(pawn.initialRank, pawn.initSquare.file, pawn)
                }
            }
        }

        fun isAcceptableMove(move: String): Boolean {
            /*return move == "exit" ||
                    (move.length == 4 &&
                            move[0] in files &&
                            move[2] in files &&
                            move[1] in ranks &&
                            move[3] in ranks)*/
            return move.matches("(exit)|([a-h][1-8][a-h][1-8])".toRegex())
        }
    }

    data class Square(var file: Char, var rank: Int) {
        fun isValidSquare(): Boolean = this.toString().matches("[a-h][1-8]".toRegex())
        override fun toString(): String = this.file.toString() + this.rank.toString()
    }

    class Move(move: String) {
        val curSquare = move.substring(0..1)
        private val newSquare = move.substring(2..3)

        val from: Square
            get() = Square(curSquare.first(), curSquare.last().toString().toInt())

        val to: Square
            get() = Square(newSquare.first(), newSquare.last().toString().toInt())
    }
  learner_created: true
- name: src/chess/ChessGame.kt
  visible: true
  text: |
    package chess

    import kotlin.math.abs

    class ChessGame {
        private lateinit var players: Array<Player>
        private val board: Board = Board()
        private var turn = 0

        private fun getName(order: String): String {
            println("$order Player's name:")
            return readLine()!!
        }

        private fun getPlayerNames() {
            players = arrayOf(
                FirstPlayer(name = getName("First")),
                SecondPlayer(name = getName("Second"))
            )
        }

        private fun setInitSquares() {
            board.structurePieces(players)
        }

        private fun promptForMove(turn: Int): String {
            println("${players[turn].name}'s turn:")
            return players[turn].requestMove()
        }

        fun play() {
            println("Pawns-Only Chess")
            getPlayerNames()
            setInitSquares()
            board.display()

            var move = ""
            while (move != "exit") {
                move = promptForMove(turn)
                if (!board.isAcceptableMove(move)) {
                    println("Invalid Input")
                    continue
                } else if (move == "exit") {
                    continue
                } else {
                    if (players[turn].movePiece(board, players[turn], move)) {
                        val m = Move(move)
                        val piece = board.getSquare(m.to.rank, m.to.file)
                        history.add(HistoryRecord(piece!!, Move(move)))
                        board.display()
                        turn++
                        turn %= 2
                    }
                }
            }
            println("Bye!")
        }

        companion object {
            data class HistoryRecord(val piece: Pawn, val move: Move)

            var history = mutableListOf<HistoryRecord>()
            lateinit var enpassant: EnPassant
            fun lastMovePiece() = history[history.lastIndex].piece
            fun lastMoveMove() = history[history.lastIndex].move
            fun lastMoveWasTwoSteps(): Boolean =
                abs(lastMoveMove().to.rank - lastMoveMove().from.rank) == 2
        }
    }

    data class EnPassant(var takingPawn: Pawn, var takenPawn: Pawn, var newSquare: Square)
  learner_created: true
- name: src/chess/Pawn.kt
  visible: true
  text: |
    package chess

    abstract class Pawn {
        abstract val color: String
        abstract val symbol: String
        abstract val initialRank: Int
        abstract val initSquare: Square
        abstract val curSquare: Square

        var isTaken: Boolean = false

        abstract fun isValidMove(to: Square, board: Board): Boolean
        abstract fun isValidCapture(to: Square, board: Board): Boolean
        abstract fun isValidEnPassant(to: Square, board: Board): Boolean
        abstract fun isOpponent(p: Pawn?): Boolean
        override fun toString(): String = symbol
        fun setCurrentSquare(newRank: Int, newFile: Char) {
            curSquare.rank = newRank
            curSquare.file = newFile
        }
    }

    class WhitePawn(initFile: Char = 'a') : Pawn() {
        override val color = "White"
        override val symbol = "W"
        override val initialRank = 2
        override val initSquare = Square(initFile, initialRank)
        override val curSquare = Square(initFile, initialRank)

        private fun isMovingForward(to: Square): Boolean {
            // e.g. from "a2" to "a3"
            return (curSquare.file == to.file) &&
                    (curSquare.rank < to.rank)
        }

        private fun isMovingFromInitPosTwoSteps(to: Square): Boolean {
            return curSquare.rank == initialRank &&
                    to.rank > curSquare.rank &&
                    to.rank - curSquare.rank == 2
        }

        private fun isMovingOneStep(to: Square): Boolean {
            return to.rank - curSquare.rank == 1
        }

        override fun isValidMove(to: Square, board: Board): Boolean {
            return board.isFree(to) &&
                    isMovingForward(to) &&
                    (isMovingOneStep(to) ||
                            isMovingFromInitPosTwoSteps(to))
        }

        override fun isValidCapture(to: Square, board: Board): Boolean {
            // find allowed capture squares
            // if "to" square in allowed capture squares
            // and "to" square contains a foe,
            // then return true; you can take foe pawn.
            val attackSqr = mutableListOf(
                Square(curSquare.file - 1, curSquare.rank + 1),
                Square(curSquare.file + 1, curSquare.rank + 1)
            ).filter {
                it.isValidSquare() && isOpponent(board.getSquare(it))
            }.filter {
                it == to
            }
            return (to in attackSqr)
        }

        override fun isValidEnPassant(to: Square, board: Board): Boolean {
            val attackSqr = mutableListOf(
                Square(curSquare.file - 1, curSquare.rank),
                Square(curSquare.file + 1, curSquare.rank)
            ).filter {
                it.isValidSquare() &&
                        isOpponent(board.getSquare(it)) &&
                        ChessGame.lastMovePiece() == board.getSquare(it) &&
                        ChessGame.lastMoveWasTwoSteps() &&
                        (to.file == ChessGame.lastMovePiece().curSquare.file &&
                                to.rank == ChessGame.lastMovePiece().curSquare.rank + 1)
    //                            if (ChessGame.lastMovePiece() is WhitePawn) 1 else -1)
            }
            return if (attackSqr.isNotEmpty()) {
                ChessGame.enpassant = EnPassant(this, ChessGame.lastMovePiece(), to)
                true
            } else
                false
        }

        override fun isOpponent(p: Pawn?): Boolean {
            return if (p == null) false
            else
                p::class != this::class
        }
    }

    class BlackPawn(initFile: Char = 'a') : Pawn() {
        override val color = "Black"
        override val symbol = "B"
        override val initialRank = 7
        override val initSquare = Square(initFile, initialRank)
        override val curSquare = Square(initFile, initialRank)

        private fun isMovingForward(to: Square): Boolean {
            // e.g. from "a7" to "a6"
            return curSquare.file == to.file &&
                    curSquare.rank > to.rank
        }

        private fun isMovingFromInitPosTwoSteps(to: Square): Boolean {
            return curSquare.rank == initialRank &&
                    to.rank < curSquare.rank &&
                    to.rank - curSquare.rank == -2
        }

        private fun isMovingOneStep(to: Square): Boolean {
            return to.rank - curSquare.rank == -1
        }

        override fun isValidMove(to: Square, board: Board): Boolean {
            return board.isFree(to) &&
                    isMovingForward(to) &&
                    (isMovingOneStep(to) ||
                            isMovingFromInitPosTwoSteps(to))
        }

        override fun isValidCapture(to: Square, board: Board): Boolean {
            // find allowed capture squares
            // if "to" square in allowed capture squares
            // and "to" square contains a foe,
            // then return true; you can take foe pawn.
            val attackSqr = mutableListOf(
                Square(curSquare.file - 1, curSquare.rank - 1),
                Square(curSquare.file + 1, curSquare.rank - 1)
            ).filter {
                it.isValidSquare() && isOpponent(board.getSquare(it))
            }.filter {
                it == to
            }
            return (to in attackSqr)
        }

        override fun isValidEnPassant(to: Square, board: Board): Boolean {
            val attackSqr = mutableListOf(
                Square(curSquare.file - 1, curSquare.rank),
                Square(curSquare.file + 1, curSquare.rank)
            ).filter {
                it.isValidSquare() &&
                        isOpponent(board.getSquare(it)) &&
                        ChessGame.lastMovePiece() == board.getSquare(it) &&
                        ChessGame.lastMoveWasTwoSteps() &&
                        (it.file == ChessGame.lastMovePiece().curSquare.file &&
                                it.rank == ChessGame.lastMovePiece().curSquare.rank - 1)
    //                            if (ChessGame.lastMovePiece() is WhitePawn) 1 else -1)
            }
            return attackSqr.isNotEmpty()
        }

        override fun isOpponent(p: Pawn?): Boolean {
            return if (p == null) false
            else
                p::class != this::class
        }
    }
  learner_created: true
- name: src/chess/Player.kt
  visible: true
  text: |
    package chess

    abstract class Player(val name: String) {
        abstract val color: String
        abstract var pieces: List<Pawn>
        val files = ('a'..'h')

        fun requestMove(): String {
            return readLine()!!
        }

        fun movePiece(board: Board, player: Player, move: String): Boolean {
            val m = Move(move)

            val from = m.curSquare
            val oldFile = m.from.file
            val oldRank = m.from.rank

            val newFile = m.to.file
            val newRank = m.to.rank

            val piece = board.getSquare(oldRank, oldFile)
            if (piece !in pieces) {
                println("No ${player.color} pawn at $from")
                return false
            }
            return when {
                piece?.isValidMove(m.to, board) == true -> {
                    // remove pawn from current square
                    // move pawn to new square
                    // set pawn's current square to new square
                    board.resetSquare(oldRank, oldFile)
                    piece.setCurrentSquare(newRank, newFile)
                    board.setSquare(newRank, newFile, piece)
                    true
                }
                piece?.isValidCapture(m.to, board)!! -> {
                    // set opponent pawn's state to taken
                    // to remove it from board
                    // remove pawn from current square
                    // move pawn to new square.
                    val opponent = board.getSquare(m.to)
                    opponent?.isTaken = true
                    board.resetSquare(opponent!!.curSquare.rank, opponent.curSquare.file)
                    board.resetSquare(piece.curSquare.rank, piece.curSquare.file)
                    piece.setCurrentSquare(newRank, newFile)
                    board.setSquare(newRank, newFile, piece)
                    true
                }
                piece.isValidEnPassant(m.to, board) -> {
                    val ep = ChessGame.enpassant
                    ep.takenPawn.isTaken = true
                    board.resetSquare(ep.takenPawn.curSquare.rank, ep.takenPawn.curSquare.file)

                    board.resetSquare(ep.takingPawn.curSquare.rank, ep.takingPawn.curSquare.file)
                    ep.takingPawn.setCurrentSquare(ep.newSquare.rank, ep.newSquare.file)
                    board.setSquare(ep.newSquare.rank, ep.newSquare.file, ep.takingPawn)
                    true
                }
                else -> {
                    println("Invalid Input")
                    false
                }
            }
        }
    }

    class FirstPlayer(name: String) : Player(name) {
        override val color = "White"
        override var pieces: List<Pawn> = files.map {
            WhitePawn(it)
        }
    }

    class SecondPlayer(name: String) : Player(name) {
        override val color = "Black"
        override var pieces: List<Pawn> = files.map {
            BlackPawn(it)
        }
    }
  learner_created: true
- name: src/input_file.txt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/13178#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Mon, 26 Sep 2022 01:16:57 UTC
record: -1
